// Code generated by MockGen. DO NOT EDIT.
// Source: utils.go

// Package utils is a generated GoMock package.
package utils

import (
	usersrespdto "authenticationService/dto/response/auth"
	token "authenticationService/pkgs/token"
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
)

// MockIUtils is a mock of IUtils interface.
type MockIUtils struct {
	ctrl     *gomock.Controller
	recorder *MockIUtilsMockRecorder
}

// MockIUtilsMockRecorder is the mock recorder for MockIUtils.
type MockIUtilsMockRecorder struct {
	mock *MockIUtils
}

// NewMockIUtils creates a new mock instance.
func NewMockIUtils(ctrl *gomock.Controller) *MockIUtils {
	mock := &MockIUtils{ctrl: ctrl}
	mock.recorder = &MockIUtilsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIUtils) EXPECT() *MockIUtilsMockRecorder {
	return m.recorder
}

// GeneratePasswordHash mocks base method.
func (m *MockIUtils) GeneratePasswordHash(password string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GeneratePasswordHash", password)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GeneratePasswordHash indicates an expected call of GeneratePasswordHash.
func (mr *MockIUtilsMockRecorder) GeneratePasswordHash(password interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GeneratePasswordHash", reflect.TypeOf((*MockIUtils)(nil).GeneratePasswordHash), password)
}

// GenerateTokenJWT mocks base method.
func (m *MockIUtils) GenerateTokenJWT(userData *usersrespdto.UserResponse, duration time.Duration) (string, *token.Claims, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenerateTokenJWT", userData, duration)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(*token.Claims)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GenerateTokenJWT indicates an expected call of GenerateTokenJWT.
func (mr *MockIUtilsMockRecorder) GenerateTokenJWT(userData, duration interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateTokenJWT", reflect.TypeOf((*MockIUtils)(nil).GenerateTokenJWT), userData, duration)
}

// MatchPassword mocks base method.
func (m *MockIUtils) MatchPassword(password, hash string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MatchPassword", password, hash)
	ret0, _ := ret[0].(bool)
	return ret0
}

// MatchPassword indicates an expected call of MatchPassword.
func (mr *MockIUtilsMockRecorder) MatchPassword(password, hash interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MatchPassword", reflect.TypeOf((*MockIUtils)(nil).MatchPassword), password, hash)
}

// ValidateJWT mocks base method.
func (m *MockIUtils) ValidateJWT(tokenString string) (*token.Claims, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateJWT", tokenString)
	ret0, _ := ret[0].(*token.Claims)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValidateJWT indicates an expected call of ValidateJWT.
func (mr *MockIUtilsMockRecorder) ValidateJWT(tokenString interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateJWT", reflect.TypeOf((*MockIUtils)(nil).ValidateJWT), tokenString)
}
